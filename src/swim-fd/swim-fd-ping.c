/*
 * (C) 2016 The University of Chicago
 * 
 * See COPYRIGHT in top-level directory.
 */
#include <ssg-config.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <assert.h>

#include <mercury.h>
#include <margo.h>
#include <ssg.h>
#include "ssg-internal.h"
#include "swim-fd.h"
#include "swim-fd-internal.h"


MERCURY_GEN_PROC(swim_member_update_t, \
    ((uint32_t) (rank)) \
    ((uint8_t)  (susp_level)) \
    ((uint32_t) (inc_nr)));

/* a swim message is the membership information piggybacked (gossiped)
 * on the ping and ack messages generated by the protocol
 */
typedef struct swim_message_s
{
    uint32_t                source_rank;
    uint32_t                source_inc_nr;
    swim_member_update_t    pb_buf[SWIM_MAX_PIGGYBACK_ENTRIES]; //TODO: can we do dynamic array instead?
} swim_message_t;

static hg_return_t hg_proc_swim_message_t(hg_proc_t proc, void *data);

MERCURY_GEN_PROC(swim_dping_req_t, \
    ((swim_message_t) (msg)));

MERCURY_GEN_PROC(swim_dping_resp_t, \
    ((swim_message_t) (msg)));

MERCURY_GEN_PROC(swim_iping_req_t, \
    ((uint32_t)       (target_member)) \
    ((swim_message_t) (msg)));

MERCURY_GEN_PROC(swim_iping_resp_t, \
    ((swim_message_t) (msg)));

DECLARE_MARGO_RPC_HANDLER(swim_dping_recv_ult)
DECLARE_MARGO_RPC_HANDLER(swim_iping_recv_ult)

static void swim_pack_message(ssg_t s, swim_message_t *msg);
static void swim_unpack_message(ssg_t s, swim_message_t *msg);

static hg_id_t dping_rpc_id;
static hg_id_t iping_rpc_id;

void swim_register_ping_rpcs(
    ssg_t s)
{
    hg_class_t *hg_cls = margo_get_class(s->mid);

    dping_rpc_id = MERCURY_REGISTER(hg_cls, "dping", swim_dping_req_t,
        swim_dping_resp_t, swim_dping_recv_ult_handler);
    iping_rpc_id = MERCURY_REGISTER(hg_cls, "iping", swim_iping_req_t,
        swim_iping_resp_t, swim_iping_recv_ult_handler);

    HG_Register_data(hg_cls, dping_rpc_id, s, NULL);
    HG_Register_data(hg_cls, iping_rpc_id, s, NULL);

    return;
}

/********************************
 *       SWIM direct pings      *
 ********************************/

static int swim_send_dping(ssg_t s, int target);

void swim_dping_send_ult(
    void *t_arg)
{
    ssg_t s = (ssg_t)t_arg;
    swim_context_t *swim_ctx;
    int target;
    int ret;

    assert(s != SSG_NULL);
    swim_ctx = s->swim_ctx;
    assert(swim_ctx != NULL);

    target = swim_ctx->ping_target;
    ret = swim_send_dping(s, target);
    if (ret == 0)
    {
        // TODO is this if check necessary?
        /* mark this dping req as acked, double checking to make
         * sure we aren't inadvertently ack'ing a ping request
         * for a more recent tick of the protocol
         */
        if(swim_ctx->ping_target == target)
            swim_ctx->ping_target_acked = 1;
    }

    return;
}

static int swim_send_dping(ssg_t s, int target)
{
    swim_context_t *swim_ctx = s->swim_ctx;
    hg_addr_t target_addr = HG_ADDR_NULL;
    hg_handle_t handle;
    swim_dping_req_t dping_req;
    swim_dping_resp_t dping_resp;
    hg_return_t hret;
    int ret = -1;

    target_addr = s->view.member_states[target].addr;
    if(target_addr == HG_ADDR_NULL)
        return(ret);

    hret = HG_Create(margo_get_context(s->mid), target_addr, dping_rpc_id,
        &handle);
    if(hret != HG_SUCCESS)
        return(ret);

    SSG_DEBUG(s, "send dping req to %d\n", target);

    /* fill the direct ping request with current membership state */
    swim_pack_message(s, &(dping_req.msg));

    /* send a direct ping that expires at the end of the protocol period */
    hret = margo_forward_timed(s->mid, handle, &dping_req,
        swim_ctx->prot_period_len);
    if (hret == HG_SUCCESS)
    {
        hret = HG_Get_output(handle, &dping_resp);
        if(hret != HG_SUCCESS)
            return(ret);

        SSG_DEBUG(s, "recv dping ack from %d\n", dping_resp.msg.source_rank);
        assert((int)dping_resp.msg.source_rank == target);

        /* extract target's membership state from response */
        swim_unpack_message(s, &(dping_resp.msg));

        ret = 0;
    }
    else if(hret != HG_TIMEOUT)
    {
        SSG_DEBUG(s, "dping req error from %d, err=%d\n", target, hret);
    }

    HG_Destroy(handle);
    return(ret);
}

static void swim_dping_recv_ult(hg_handle_t handle)
{
    ssg_t s;
    swim_context_t *swim_ctx;
    struct hg_info *info;
    swim_dping_req_t dping_req;
    swim_dping_resp_t dping_resp;
    hg_return_t hret;

    /* get ssg & swim state */
    info = HG_Get_info(handle);
    if(info == NULL)
        return;
    s = (ssg_t)HG_Registered_data(info->hg_class, dping_rpc_id);
    assert(s != SSG_NULL);
    swim_ctx = s->swim_ctx;
    assert(swim_ctx != NULL);

    hret = HG_Get_input(handle, &dping_req);
    if(hret != HG_SUCCESS)
        return;

    SSG_DEBUG(s, "recv dping req from %d\n", dping_req.msg.source_rank);

    /* extract sender's membership state from request */
    swim_unpack_message(s, &(dping_req.msg));

    /* fill the direct ping response with current membership state */
    swim_pack_message(s, &(dping_resp.msg));

    SSG_DEBUG(s, "send dping ack to %d\n", dping_req.msg.source_rank);

    /* respond to sender of the dping req */
    margo_respond(s->mid, handle, &dping_resp);

    HG_Destroy(handle);
    return;
}
DEFINE_MARGO_RPC_HANDLER(swim_dping_recv_ult)

/********************************
 *     SWIM indirect pings      *
 ********************************/

void swim_iping_send_ult(
    void *t_arg)
{
    ssg_t s = (ssg_t)t_arg;
    swim_context_t *swim_ctx;
    int i;
    int my_subgroup_member = SSG_MEMBER_RANK_UNKNOWN;
    hg_addr_t target_addr = HG_ADDR_NULL;
    hg_handle_t handle;
    swim_iping_req_t iping_req;
    swim_iping_resp_t iping_resp;
    hg_return_t hret;

    assert(s != SSG_NULL);
    swim_ctx = s->swim_ctx;
    assert(swim_ctx != NULL);

    for(i = 0; i < swim_ctx->prot_subgroup_sz; i++)
    {
        if(swim_ctx->subgroup_members[i] != SSG_MEMBER_RANK_UNKNOWN)
        {
            my_subgroup_member = swim_ctx->subgroup_members[i];
            swim_ctx->subgroup_members[i] = SSG_MEMBER_RANK_UNKNOWN;
            break;
        }
    }
    assert(my_subgroup_member != SSG_MEMBER_RANK_UNKNOWN);

    target_addr = s->view.member_states[my_subgroup_member].addr;
    if(target_addr == HG_ADDR_NULL)
        return;

    hret = HG_Create(margo_get_context(s->mid), target_addr, iping_rpc_id,
        &handle);
    if(hret != HG_SUCCESS)
        return;

    SSG_DEBUG(s, "send iping req to %d, target=%d\n",
        my_subgroup_member, swim_ctx->ping_target);

    /* fill the indirect ping request with target member and current
     * membership state
     */
    iping_req.target_member = swim_ctx->ping_target;
    swim_pack_message(s, &(iping_req.msg));

    /* send this indirect ping */
    /* NOTE: the timeout is just the protocol period length minus
     * the dping timeout, which should cause this iping to timeout
     * right at the end of the current protocol period.
     */
    hret = margo_forward_timed(s->mid, handle, &iping_req,
        (swim_ctx->prot_period_len - swim_ctx->dping_timeout));
    if (hret == HG_SUCCESS)
    {
        hret = HG_Get_output(handle, &iping_resp);
        if(hret != HG_SUCCESS)
            return;

        SSG_DEBUG(s, "recv iping ack from %d, target=%d\n",
            iping_resp.msg.source_rank, swim_ctx->ping_target);

        /* extract target's membership state from response */
        swim_unpack_message(s, &(iping_resp.msg));

        // TODO is this if check necessary?
        /* mark this iping req as acked, double checking to make
         * sure we aren't inadvertently ack'ing a ping request
         * for a more recent tick of the protocol
         */
        if(swim_ctx->ping_target == (int)iping_req.target_member)
            swim_ctx->ping_target_acked = 1;
    }
    else if(hret != HG_TIMEOUT)
    {
        SSG_DEBUG(s, "iping req error from %d, err=%d, target=%d\n",
            my_subgroup_member, hret, swim_ctx->ping_target);
    }

    HG_Destroy(handle);
    return;
}

static void swim_iping_recv_ult(hg_handle_t handle)
{
    ssg_t s;
    swim_context_t *swim_ctx;
    struct hg_info *info;
    swim_iping_req_t iping_req;
    swim_iping_resp_t iping_resp;
    hg_return_t hret;
    int ret;

    /* get the swim state */
    info = HG_Get_info(handle);
    if(info == NULL)
        return;
    s = (ssg_t)HG_Registered_data(info->hg_class, dping_rpc_id);
    assert(s != SSG_NULL);
    swim_ctx = s->swim_ctx;
    assert(swim_ctx != NULL);

    hret = HG_Get_input(handle, &iping_req);
    if(hret != HG_SUCCESS)
        return;

    SSG_DEBUG(s, "recv iping req from %d, target=%d\n",
        iping_req.msg.source_rank, iping_req.target_member);

    /* extract sender's membership state from request */
    swim_unpack_message(s, &(iping_req.msg));

    /* send direct ping to target on behalf of who sent iping req */
    ret = swim_send_dping(s, iping_req.target_member);
    if(ret == 0)
    {
        /* if the dping req succeeds, fill the indirect ping
         * response with current membership state
         */
        swim_pack_message(s, &(iping_resp.msg));

        SSG_DEBUG(s, "send iping ack to %d, target=%d\n",
            iping_req.msg.source_rank, iping_req.target_member);

        /* respond to sender of the iping req */
        margo_respond(s->mid, handle, &iping_resp);
    }

    HG_Destroy(handle);
    return;
}
DEFINE_MARGO_RPC_HANDLER(swim_iping_recv_ult)

/********************************
 *      SWIM ping helpers       *
 ********************************/

static void swim_pack_message(ssg_t s, swim_message_t *msg)
{
    memset(msg, 0, sizeof(*msg));

    /* fill in self information */
    msg->source_rank = s->view.self_rank;
    msg->source_inc_nr = s->view.member_states[s->view.self_rank].swim_inc_nr;

#if 0
    /* piggyback a set of membership states on this message */
    swim_retrieve_membership_updates(swim_ctx, msg->pb_buf,
        SWIM_MAX_PIGGYBACK_ENTRIES);
#endif

    return;
}

static void swim_unpack_message(ssg_t s, swim_message_t *msg)
{
    swim_member_update_t sender_update;

    /* TODO: use unsuspect_member? -- update state of the sender of this message */
    sender_update.rank = msg->source_rank;
    sender_update.susp_level = 0;
    sender_update.inc_nr = msg->source_inc_nr;
#if 0
    swim_apply_membership_updates(swim_ctx, &sender_state, 1);

    /* update membership status using piggybacked membership states */
    swim_apply_membership_updates(swim_ctx, msg->pb_buf,
        SWIM_MAX_PIGGYBACK_ENTRIES);
#endif

    return;
}

/* manual serialization/deserialization routine for swim messages */
static hg_return_t hg_proc_swim_message_t(hg_proc_t proc, void *data)
{
    swim_message_t *msg = (swim_message_t *)data;
    hg_return_t hret = HG_PROTOCOL_ERROR;
    int i;

    switch(hg_proc_get_op(proc))
    {
        case HG_ENCODE:
            hret = hg_proc_int32_t(proc, &(msg->source_rank));
            if(hret != HG_SUCCESS)
            {
                hret = HG_PROTOCOL_ERROR;
                return hret;
            }
            hret = hg_proc_uint32_t(proc, &(msg->source_inc_nr));
            if(hret != HG_SUCCESS)
            {
                hret = HG_PROTOCOL_ERROR;
                return hret;
            }
            for(i = 0; i < SWIM_MAX_PIGGYBACK_ENTRIES; i++)
            {
                hret = hg_proc_swim_member_update_t(proc, &(msg->pb_buf[i]));
                if(hret != HG_SUCCESS)
                {
                    hret = HG_PROTOCOL_ERROR;
                    return hret;
                }
            }
            break;
        case HG_DECODE:
            hret = hg_proc_int32_t(proc, &(msg->source_rank));
            if(hret != HG_SUCCESS)
            {
                hret = HG_PROTOCOL_ERROR;
                return hret;
            }
            hret = hg_proc_uint32_t(proc, &(msg->source_inc_nr));
            if(hret != HG_SUCCESS)
            {
                hret = HG_PROTOCOL_ERROR;
                return hret;
            }
            for(i = 0; i < SWIM_MAX_PIGGYBACK_ENTRIES; i++)
            {
                hret = hg_proc_swim_member_update_t(proc, &(msg->pb_buf[i]));
                if(hret != HG_SUCCESS)
                {
                    hret = HG_PROTOCOL_ERROR;
                    return hret;
                }
            }
            break;
        case HG_FREE:
            /* do nothing */
            hret = HG_SUCCESS;
            break;
        default:
            break;
    }

    return(hret);
}
